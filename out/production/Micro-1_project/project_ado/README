1)
To get started, determine which methods Memory and Processor need. This can be
determined from studying Console.java and the UML class diagram.
Quickly create Memory and Processor classes with these methods. Don't worry about how the methods
should work. The only important thing is that the program compiles and runs.

2)
Next,replace the implementation of the Memory methods with ones that work. This should be
easy, but may involve adding fields to the class.

3)
Then replace the implementation of the Processor methods with ones that work.
This may also involve adding fields to the Processor class. Finally, test your program on program1.m1.

4)
Processor.java will need to make use of Java's right shift (>>) and bitwise conjunction (&)
to mask out and shift fields of IR representing opcodes and arguments.

5)
Testing
Test your implementation by writing and running the following Micro-1 programs:
1. cell[103] = 3 * cell[100] + 2 * cell[101] + cell[102]
2. cell[101] = 2cell[100] // hint: use left shift
3. cell[101] = cell[100] + cell[100]>>1 + cell[100]>>2 + ... + 1
Note: these numbers are in base 10.

6)
Add an assembler
Modify the load method in the Console class so that it reads a file containing Micro-1
assembly language instructions instead of hexadecimal machine language instructions.
The translation should be easy. For example:
add a b translates into the hexadecimal number 4ab
Interpret everything in the file after the halt instruction as a hexadecimal constant.

7)
Add a GUI
Replace Console.java with Micro1Viewer.java. The viewer contains a control panel
(JPanel) with text fields (JTextField) showing the current content of each register, and
buttons (JButton) for the Console commands: step, load, memory (dumps to the
command console), and registers (updates the text fields.)